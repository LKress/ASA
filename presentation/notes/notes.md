## Slide 1

* introduction Flye, algorithm for long, error-prone read assembly

## Slide 2

* already known assembly -> reconstruction from reads 

* for this reconstruction diff assemblers use different graph structures

* due to repeats in the genome the assembly gets fragmented and leads to tangled assembly graphs which are hard to resolve and which leads to fragmentation

* longer reads can resolve short repeats by spanning them but with the issue of higher error rate in long reads compared to short reads resolution of longer repeats is still complicated
-> SD and mosaic structures 

* Flye assembly algorithm, able to create assemblies which have a higher contiguity than state of the art and is able to characterize most of the repeats 
    * using repeat graphs to resolve the repeats by graph topological analysis

## Slide 3

* spend much time 

* to resolve the repeats correctly Flye uses a different approach 

* we don't care about correct repeat resolution

* at least at initial stage

* generate paths accepting the possibility of concatenating disjoint genomic regions, we call these disjointigs

## Slide 4

* we use a repeat graph which is generalized form of a de Bruijn graph, to generate this we start of with the reads from this example genome which contains two repeats R and R1

## Slide 5

* from the reads we create the disjointigs which may lead joining reads of disjoint genomic regions (e.g. x r v)

* after that the disjointigs are concatenated to a single string seperated by delimiters

## Slide 6

* back to basics we perform a self alignment of the disjointig against itself 

* the repeats are displayed above the main diagonal (which is the trivial alignment against the same position) 

* we project the endpoints of these repeats to the main diagonal 

-> endpoints übergänge repeat nicht repeat and vice versa
## Slide 7

* now the same colored poins are clustered together which gives us the repeat graph on the right hand side

* by clustering together the same colored edges we recieve the final repeat graph

## Slide 8

* using several repeat resolution steps based on the repeat graph structure Flye is able to achive almost a 2-fold improvement in contiguity compared to Canu Masurca 

* using the algorithm Flye we can achieve a higher contiguity than the state of the art assemblers Canu and MaSuRCA

* the benchmark dataset is a ONT human dataset and the assemblers Canu and Flye were improved using Pilon

-> Pilon in references

* the reference identity is almost the same as the other assemblers (take into account that the y scale is quite narrow)

* reference coverage is higher than the other assemblers the y axis is quite narrow here as well

* the number of missassemblies is a magnitude lower compared to the other assemblers

* if you want to see more results generated by flye, the improvements since we started the development or learn more about our methods make sure to visit our poster
* See you there